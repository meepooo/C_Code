zookeeper

ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，
是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。
ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
ZooKeeper包含一个简单的原语集，提供Java和C的接口。
ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，
代码在zookeeper-3.4.3\src\recipes。其中分布锁和队列有Java和C两个版本，选举只有Java版本。

特点：
在Zookeeper中，znode是一个跟Unix文件系统路径相似的节点，可以往这个节点存储或获取数据。
如果在创建znode时Flag设置为EPHEMERAL，那么当创建这个znode的节点和Zookeeper失去连接后，
这个znode将不再存在在Zookeeper里，Zookeeper使用Watcher察觉事件信息。当客户端接收到事件信息，
比如连接超时、节点数据改变、子节点改变，可以调用相应的行为来处理数据。
Zookeeper的Wiki页面展示了如何使用Zookeeper来处理事件通知，队列，优先队列，锁，共享锁，可撤销的共享锁，两阶段提交。
那么Zookeeper能做什么事情呢，简单的例子：
假设我们有20个搜索引擎的服务器(每个负责总索引中的一部分的搜索任务)和一个总服务器(负责向这20个搜索引擎
的服务器发出搜索请求并合并结果集)，一个备用的总服务器(负责当总服务器宕机时替换总服务器)，
一个web的cgi(向总服务器发出搜索请求)。搜索引擎的服务器中的15个服务器提供搜索服务，
5个服务器正在生成索引。这20个搜索引擎的服务器经常要让正在提供搜索服务的服务器停止提供服务开始生成索引，
或生成索引的服务器已经把索引生成完成可以提供搜索服务了。
使用Zookeeper可以保证总服务器自动感知有多少提供搜索引擎的服务器并向这些服务器发出搜索请求，
当总服务器宕机时自动启用备用的总服务器。

应用场景-屏障

1.Client在Zookeeper上创建屏障节点，并启动各任务

2.每个任务在exist()并设置watch。

3.调用creat()创建屏障节点的临时子节点。

4.判断子节点的数量是否等于指定的值。

5.是则删除屏障节点，否则离开。





应用场景-分布式锁

1.调用create()创建锁节点的临时顺序节点。

2.调用getChildren()在锁节点。

3.判断子节点的最小节点是否是自己创建的节点。

4.是则获取锁

5.否则没有获取锁，调用exists()监听比自己创建节点最小的节点。

6.如果返回false，则调到第二步，否则等待



讨论：
1.分布式锁的其他实现方案

2.双屏障如何实现

3.公平模式选举如何实现